---
title: "Non-model species enrichment analysis with clusterProfiler"
output:
  html_document:
    df_print: paged
    self_contained: false
---




THOUGHTS - instead of doing GO and KEGG, just do GO, but do it for the manual annotation and compare to the STRING annotation. 



```{r  Load libraries, include=FALSE }
# for readTSV
library(readr)

# for %>% syntax and GSEA
library(dplyr)

# for extracting ontology from go.obo
library(ontologyIndex)

# required for drop.na()
library(tidyverse)

library(DESeq2)
library(clusterProfiler)

# upset plot
library(enrichplot) # gsea plot
library(ggupset)

```


# Non-model species

## Options for species with the right annotation resources

FEA can be easily performed for many non-model species with user friendly web tools (eg g:Profiler) or R packages. For clusterProfiler, organisms with the required annotations can be analysed using the convenient tools enrichGO, enrichKEGG, gseGO, gseKEGG etc. If a species is listed on [KEGG Organisms](https://www.genome.jp/kegg/tables/br08606.html), they can be analysed online or with clusterProfiler using enrichKEGG or gseKEGG. To use enrichGO or gseGO, an [Org.db annotation package](https://bioconductor.org/packages/3.19/data/annotation/) is required. 

## What options are available if your species does not have either of these two resources? 

If you have performed an in-house genome assembly or are working with an understudied species, it is unlikely/impossible that your species will have the required annotations and thus your options for performing FEA become limited. How frustrating, given that you are already faced with numerous challenges working with an under-resourced species!

This is where the flexibility of R can help, in particular clusterProfiler which has some generic functions for ORA (function 'enricher') and GSEA (function 'GSEA') that allow you to input your own annotation database in the form of two complimentary files, 'TERM2GENE' (maps your specific organism gene IDs to annotation IDs) and 'TERM2NAME' (maps those annotation IDs to descriptive names, eg GO term 'GO:0003676' is mapped to name 'nucleic acid binding'. These sound complicated but are simply 2-column text files. 

The gene names are flexible - they do not have to conform to any specific gene ID namespace. In order to obtain the functional annotations, you may need to run the annotation yourself with tools such as eggNog emapper, which will provide annotations against GO, KEGG and a number of other databases. In order to run the annotation, you of course need a genome assembly and gene prediction GTF/GFF file. You can then filter the annotation output for the correct fields (ie organisms-specific gene ID and annotation ID) in order to create the 'TERM2GENE' file. 

To create 'TERM2NAME', you then use the relevant database eg (GO, KEGG) to create a text file with the annotation IDs detected in your organism to the annotation names. 

# Axolotl functional enrichment analysis

## Background 

The axolotl (Ambystoma mexicanum) is a salamander with some very cool abilities: it can regenerate damaged or amputated tissue, including spinal cord and some brain regions. While this species has reference genome on NCBI, it is not annotated. There is no Org.db nor does this species exist in KEGG Organisms. There is however an [axolotl genome browser](https://www.axolotl-omics.org/) where you can download a (slightly less contiguous than the NCBI version) reference genome plus a (non-curated) GTF file.

Despite the lack of quality resources, there is much 'omics work conducted in axolotl due to its regenerative capabilities.

Today we will use [public RNAseq data](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5419050/#SD7) from axolotl, comparing gene expression in the blastema after proximal (at the shoulder) and distal (at the hand) limb amputation. The blastema is a collection of undifferentiated progenitor cells that give rise to the regenerated limb. Hopefully, our functional enrichment analysis of differentially expressed genes can help us understand what tells the blastema to grow into a full limb or just a hand! 

### Raw data sources

- [Reference genome](https://www.axolotl-omics.org/dl/AmexG_v6.0-DD.fa.gz)
- [GTF file](https://www.axolotl-omics.org/dl/AmexT_v47-AmexG_v6.0-DD.gtf.gz)
- [Raw fastq](https://www.ncbi.nlm.nih.gov/bioproject/PRJNA300706)
- [GO 'core' ontology file](https://purl.obolibrary.org/obo/go.obohea)

**ADD GO.OBO

### Data pre-processing

The reference genome was annotated with emapper and GO and KEGG IDs extracted to create required database files. The raw reads were trimmed with bbduk and aligned to the reference genome with STAR. Feature counting was performed with HTSeq-counts and formatted into a counts matrix. Differential gene expression analysis was performed with DESeq2, filtering for genes with at least a count of 10 in at least 2 samples. The background gene lists (DEGs filtered for P.adj < 0.05 and log2fold change 1, background genes, genes ranked on log2fold change) have been exracted from this DESeq2 results file, and included in your 'day_2' folder for input into this analysis.  


## Load input genes


```{r}
knitr::opts_knit$set(root.dir = "Functional_enrichment_workshop_2024/day_2")
```



```{r}
de_matrix <- read_tsv("axolotl_DE_results.txt", col_names = TRUE, show_col_types = FALSE)

head(de_matrix)


```


```{r}
# Assuming your dataframe is named 'full_data'

# 1. Extract DEGs based on your criteria
degs <- de_matrix %>%
  filter(padj < 0.01 & abs(log2FoldChange) > 1.5) %>%
  pull(geneID)  # Extract gene IDs as a vector

# 2. Extract the background gene list
background <- de_matrix %>%
  pull(geneID)  # Extract all gene IDs as a background vector

# 3. Create the ranked gene vector for GSEA
ranked <- setNames(de_matrix$log2FoldChange, de_matrix$geneID) %>% sort(decreasing = TRUE)  # Named vector

# Check the results
length(degs)         # Number of DEGs
length(background)   # Number of background genes
head(ranked)  # Preview of the ranked vector

```



## Gene Ontology enrichment 

### Load axolotl GO annotation file

The file `Amex_term2gene_GO.tsv` was created by extracting the GO terms mapped to the axolotl genes with emapper, and printing them one term per line alongside the gene ID. A gene can map to many terms and thus be present on multiple lines. A term can be mapped to more than one gene. 


```{r load GO annotation}

# load annotation input file
infile <- "Amex_term2gene_GO.tsv"
go_term2gene <- read_tsv(infile, show_col_types = FALSE)

# assign column names
colnames(go_term2gene) <- c("term", "gene")

# print the first 6 lines
head(go_term2gene)

```

Now print the number of GO terms found within the genome, and the number of genes with GO annotations

```{r report GO annotation counts}

total_terms<-nrow(go_term2gene)
print(paste("Number of annotation terms:", total_terms))

unique_genes <- length(unique(go_term2gene$gene))
print(paste("Number of genes with 1 or more annotation terms:", unique_genes))

```






### Create TERM2NAME

The 'core' gene ontology database file [`go.obo`](https://purl.obolibrary.org/obo/go.obo) has been downloaded and included in your working directory. This will enable us to assign GO names to all of the GO IDs within our axolotl 'TERM2GENE' file.  

Prepare the term to name table:

```{r GO term2name}

# Extract ontology info from go.obo

infile <- "go.obo"

ontology <- get_ontology(file = infile,
                         propagate_relationships = "is_a",
                         extract_tags = "everything",
                         merge_equivalent_terms = TRUE)


# Create term to name table, removing duplicates, missing values and obsolete terms 
go_term2name <- go_term2gene %>%
    mutate(name = ontology$name[term]) %>%
    dplyr::select(term, name) %>%
    distinct() %>%
    drop_na() %>%
    filter(!grepl("obsolete", name))



# Write to a file
write_tsv(go_term2name, "Amex_term2name_GO.tsv")

# Show the first few lines
head(go_term2name)

```


### Annotated background genes


We know that we have 24,419 background genes, and 21,373 genes annotated with GO terms. How many of our background genes are annotated? 


```{r report GO annotation percentages}


# Filter the term2gene table to only include genes in the background gene list
filtered_term2gene <- go_term2gene %>% filter(gene %in% background)

# Count the number of unique background genes with at least one GO term
unique_genes_with_anno <- filtered_term2gene %>% distinct(gene) %>% nrow()

# Calculate the percentage of background genes that have GO annotations
percent_annotated_filtered <- (unique_genes_with_anno / length(background)) * 100

# Print results
cat("Number of background genes with GO annotations:", unique_genes_with_anno, "(",percent_annotated_filtered,"%)\n")


```


How does that compare to the number of genes genome-wide? From the axolotl gene prediction file downloaded from www.axolotl-omics.org, there were 99,088 predicted gene models! In order to annotate these with eggnog emapper and STRING, a proteome was made to include all predicted coding sequences, restricting to a single isoform per gene, and this was a total of 48,115 predicted proteins. 

So the annotation percentages are:

- based on genome-wide gene predictions: 21.6%
- based on predicted coding sequence: 48.6% 
- based on genes that were expressed within the tissue: 61.7% 



This highlights a major caveat when performing FEA on non-model species: the results are only as good as the annotations behind them. Therefore, all results must be interpreted with caution. For many non-model species, there are little opportunities (at present) to improve the annotation. Some in-silico predicted genes appear to be highly expressed and significantly regulated yet have no significant similarity to anything in the non-redundant nucleotide or protein databases. When working with datasets like this, it is critical to explore those individual genes through other methods, in addition to trying to garner some higher level overview such as we aim to obtain from FEA. Hopefully, recent advances in AI protein modelling can help provide insights into the functions of these novel genes. 

For the axolotl with only 22% of predicted genes annotated, its clear that the in-silico gene predictions within the GTF file require much curation! 



### ORA (GO)

#### Create input list for ORA

We have filtered our DEGs to include genes with P.adj < 0.01  and log2 fold change greater than |2|. 

How many of these are annotated?  Genes that have no annotations provide no meaning to the functional enrichment analysis so must be excluded

```{r count annotated DEGs }

# Extract the gene IDs from the term2gene file
annotated_genes <- go_term2gene$gene

# Find significant genes that have annotations
annotated_degs <- degs[degs %in% annotated_genes]

# Percentage of DEGs that are annotated
pc <-  round((length(annotated_degs) / length(degs)) * 100, 1)

# Print the result
cat("Number of DEGs at 5% threshold:", length(degs), "\nNumber of DEGs annotated with GO terms:", length(annotated_degs), "(",pc,"%)\n")

```
This is quite a bit  lower than the percentage of background genes with GO annotations, which was 61.7%. What are these 41% of clearly important (dysregualted) genes that were not annotated by DIAMOND similarity search against the GO database? This is the problem with novel species analysis - you must keep in mind that there is a fair bit of data loss, and other investigations are warranted!





#### Run ORA

Now that we have our input gene lists and our required `TERM2GENE` and `TERM2NAME` files, we can run FEA on axolotl! 

The `enricher` functon has a number of significance thresholds you can apply. 

Tests must pass i) pvalueCutoff on unadjusted pvalues, ii) pvalueCutoff on adjusted pvalues and iii) qvalueCutoff on qvalues to be reported. With identical cutoff values used for both pvalueCutoff (since pAdjustMethod = "BH", these are thus FDR values) and qvalueCutoff, you effectively will always filter on BH adjusted p-values and NOT q-values, because the BH procedure generates more conservative FDR than Storey's qvalue approach. If you would like to filter on qvalue, set pAdjustMethod = "none".

```{r GO ORA }

# Perform ORA with clusterProfiler's 'enricher' function 

go_ora <- enricher(
  gene = degs,
  pvalueCutoff = 0.05,
  pAdjustMethod = "BH",
  universe = background,
  minGSSize = 10,
  maxGSSize = 500,
  TERM2GENE = go_term2gene,
  TERM2NAME = go_term2name
)

# view result summary
go_ora

```

91 significantly enriched terms at P.adj < 0.05. 

Save the results to a text file:


```{r save ORA table}

output_file <- "axolotl_GO_ORA_results.tsv"
write.table(go_ora, file = output_file, sep = "\t", quote = FALSE, row.names = FALSE)	

	
```




#### Dotplot GO ORA 

```{r}

# Create plot with dynamic title
p <- dotplot(
  go_ora,
  x = "geneRatio",
  color = "p.adjust",
  orderBy = "x",
  showCategory = 15,
  font.size = 8
  ) +
  ggtitle("ORA enrichment of DEGs Padj < 0.01 FC > |1.5|, db = GO")
    
# Add annotations (number of input genes and number of input genes with GO terms)
num_genes <- length(degs)
genes_with_GO_terms <- sum(degs %in% go_term2gene$gene)

    
# Print the plot with custom sub-title
p <- p + labs(subtitle = paste("Genes:", num_genes, "| Genes with GO terms:", genes_with_GO_terms))
print(p)

```

Showing the number of DEGs that were actually annotated and included in the FEA is very important for novel species, where the annotation quality may (probably is) low. In this case, we need to keep in mind that 102 of the DEGs were not included in the analysis! These may be very interesting genes, and it is up to you as the researcher to investigate those genes to determine their importance through other means. 



#### Upset plot GO ORA

And an upset plot - to show the shared genes among the enriched terms (since a gene can belong to multiple terms or pathways)
For over-representation analysis, upsetplot will calculate the overlaps among different gene sets. For GSEA, it will plot the fold change distributions of different categories (e.g. unique to pathway, overlaps among different pathways).

```{r upset plot}

# n = the number of top enrichments to plot
upsetplot(go_ora, n = 10)

```


#### Bar plot GO ORA

```{r}
barplot(go_ora, 
        drop = TRUE, 
        showCategory = 15, 
        title = "ORA enrichment of DEGs Padj < 0.01 FC > |1.5|, db = GO",
        font.size = 8)
```

#### emapplot GO ORA

The encrichment map organizes enriched terms into a network with edges connecting overlapping gene sets. Overlapping gene sets cluster together.

To run this function, we first need to calculate pairwise similarities between the enriched terms with function `pairwise_termsim`. 



```{r emapplot }
# calculate pairwise similarities between the enriched terms
go_ora <- pairwise_termsim(go_ora)

# plot
emapplot(go_ora, showCategory = 15)

```

From here: https://yulab-smu.top/biomedical-knowledge-mining-book/enrichplot.html 

"Both the barplot() and dotplot() only displayed most significant or selected enriched terms, while users may want to know which genes are involved in these significant terms. In order to consider the potentially biological complexities in which a gene may belong to multiple annotation categories and provide information of numeric changes if available, we developed the cnetplot() function to extract the complex association. The cnetplot() depicts the linkages of genes and biological concepts (e.g. GO terms or KEGG pathways) as a network. GSEA result is also supported with only core enriched genes displayed."

cnetplot: https://rdrr.io/bioc/enrichplot/man/cnetplot.html 


```{r cnetplot}
# cex_label_gene to reduce the font size for gene ID
# colorEdge adds the coloured legend and network bars 

cnetplot(go_ora, showCategory = 15, node_label = "category")
```








#### Tree plot GO ORA

```{r}
treeplot(go_ora, showCategory = 15, color = "p.adjust")
```



#### What is the biological meaning here?

I was expecting to see growth factors, regulatory genes and morphogens. We are seeing enrichment for things we already know are involved in limb and skin formation. It may be that the genes regulating this patterning in axolotl are some of those novel genes (not annotated to any GO terms), or that this was completely the wrong experiment type :-) It was a dummy experiment contrived from public data where the results were generated for genome assembly purposes, and not an actual DE study, so please don't read into the actual resutls too much :-) 


### GSEA (GO)


#### Run GSEA

```{r}
go_gsea <- GSEA(geneList = ranked, 
                     TERM2GENE = go_term2gene, 
                     TERM2NAME = go_term2name, 
                     pvalueCutoff = 0.05, 
                     verbose = TRUE)

```

```{r}
head(go_gsea)
```




#### Plot GSEA

gsea-specific:
ridgeplot
gseaplot

for ora or gsea:

dotplot
upsetplot
emapplot
treeplot
heatplot
cnetplot

for ora only (weirdly):
barplot




## KEGG enrichment 

### Load axolotl KEGG annotation file

The file `Amex_term2gene_KEGG.tsv` was created by extracting the KEGG IDs mapped to the axolotl genes with emapper, and printing them one term per line alongside the gene ID. A gene can map to many terms and thus be present on multiple lines. A term can be mapped to more than one gene. 


```{r load KEGG annotation}

# load annotation input file
infile <- "Amex_term2gene_KEGG.tsv"
term2gene_kegg <- read_tsv(infile, show_col_types = FALSE)

# assign column names
colnames(term2gene_kegg) <- c("term", "gene")

# print the first 6 lines
head(term2gene_kegg)

```

Now print the number of KEGG IDs found within the genome, and the number of genes with KEGG annotations

```{r report KEGG annotation counts}

total_terms_kegg<-nrow(term2gene_kegg)
print(paste("Number of annotation terms:", total_terms_kegg))

unique_genes_kegg <- length(unique(term2gene_kegg$gene))
print(paste("Number of genes with 1 or more annotation terms:", unique_genes_kegg))

```
Ouch, this is a lot lower than GO!


### Define background genes

Our background gene list for KEGG is the same as it was for GO. Let's find out how many of our background have KEGG annotations. 


```{r report KEGG annotation percentages}

# from raw counts
percent_annotated_raw <- (unique_genes / (nrow(raw_counts))) * 100

# Now filter the term2gene table to only include genes in the background gene list
filtered_term2gene <- term2gene %>% filter(gene %in% background_genes)

# Count the number of unique background genes with at least one GO term
unique_genes_with_anno <- filtered_term2gene %>% distinct(gene) %>% nrow()

# Calculate the percentage of background genes that have GO annotations
percent_annotated_filtered <- (unique_genes_with_anno / nrow(filtered_counts)) * 100

# Print results
cat("Number of background genes with annotationss:", unique_genes_with_anno, "(",percent_annotated_filtered,"%)\n")
cat("Percentage of genome-wide genes with annotations:", percent_annotated_raw, "%\n")

```
KEGG annotations are present for almost half the number of background and genome-wide genes. Is it really worth pursuing this analysis? Let's just run it anyway (since the code is copy and paste, thanks R!)


### ORA (KEGG)

#### Create input list for ORA



#### Run ORA


#### Plot ORA


### GSEA (KEGG)


#### Create input list for GSEA



#### Run GSEA


#### Plot GSEA

