---
title: "Enrichment with clusterProfiler and visualisation with enrichplot"
output:
  html_document:
    df_print: paged
---

```{r Load R packages, include=FALSE}
library(clusterProfiler)
library(enrichplot)
library(readr)
library(biomaRt)
library(org.Hs.eg.db)
library(dplyr)
library(ggupset)
library(ggplot2)
```


Ensure the 'workshop' directory is your current working directory:

```{r check notebook workdir}
getwd()
```

# 1. Load input data and extract ranked gene list

We will once again load the Pezzini RNAseq dataset.

```{r load input data}

data <- read_tsv("Pezzini_DE.txt", col_names = TRUE, show_col_types = FALSE)
head(data)
```


This time, instead of filtering for DEGs, we will extract all genes, and sort them by fold change (largest to smallest). The R object type for `gseKEGG` needs to be a 'vector'. Unfortunately, this detail is under the `enrichKEGG` function, not the `gseKEGG` function! For `enrichKEGG`, the parameter `gene` is described as requiring "a vector of entrez gene id", yet for `gseKEGG`, the description for `geneList` is "order ranked geneList". There is a little bit of sleuthing required at times! 



```{r extract ranked list}

# Ranked gene list vector for GSEA
ranked <- setNames(data$Log2FC[order(-data$Log2FC)], data$Gene.ID[order(-data$Log2FC)])

# Inspect the vector
head(ranked)
tail(ranked)

```


# 2. Check `gseKEGG` function arguments and requirements

Let's start by reviewing the function arguments. Once you run the below code chunk, the user guide for the function will open in the `Help` pane of RStudio (lower right) 

```{r help gsekegg}
?gseKEGG
```


Most of those defaults look suitable to start. 

We have human so the default `organism = "hsa"` argument is correct. If you were working with a species other than human, you first need to obtain your organism code. You can derive this from [KEGG Organisms](https://www.genome.jp/kegg/tables/br08606.html) or using the `clusterProfiler` function `search_kegg_organism`.


Pick your favourite species and search for the KEGG organism code by editing the variable 'organism' then executing the code chunk:

```{r}
fave <- "horse"

# search by common_name or scientific_name 
search_kegg_organism(fave, by = "common_name")
```


Now back to the parameters - the defaults for P value correction and filtering, and gene set size limits are acceptable. We don't want to use internal data (i.e. we want to search against the latest KEGG online) so `FALSE` is apt here, and we do want to use the `fgsea` algorithm for analysis. 

For the `seed` parameter, we should provide a value, to ensure results are the same each time the command is run. By setting a seed, you fix the sequence of random numbers generated within the GSEA algorithm.

We also need to check the `keyType` (gene namespace) against the input data that we have. From the help page, we can see the supported namespaces for the KEGG database are one of 'kegg', 'ncbi-geneid', 'ncib-proteinid' or 'uniprot'.

Going back to where we loaded the input data and ran `head` to view the first few rows, we can see our input has ENSEMBL gene IDs as well as official gene symbols. ENSEMBL gene IDs are generally preferable for bioinformatics analyses because they are more unique and stable compared to gene symbol.

Since our input data does not match any of the valid namespaces, we need to convert gene IDs! `clusterProfiler` has the `bitr` function to do this. `BiomaRt` is also a popular R package for this task. 


# 3. Convert gene IDs 

Check the usage for the `bitr` function:

```{r}
?bitr
```

We need to understand what the valid `fromType` and `toType` values are, and it turns out we need an Org.db to use `bitr`! This is a Bioconductor annotation package, of which there are currently only 20. So while the `gseKEGG` function supports all organisms in KEGG, performing gene ID conversion within ``clusterProfiler` may not be possible for non-model species and you would need to seek a different method.  

We have already loaded the `org.Hs.eg.db` annotation library. We can use this to search `keytypes`:

```{r}
keytypes(org.Hs.eg.db)
```

Converting to ENTREZ will be compatible with `kegg`. So our `fromType` is `ENSEMBL` and `toType` is `ENTREZID`. Note that these are case sensitive! 

If we were to run `enrichGO` or `gseaGO` that require a Bioconductor Org.db package, we would not need to do a conversion, as both of the gene ID types within our input data (`ENSEMBL` and `SYMBOL`) are natively supported. 

The below code performs the reformatting and handles duplicates by keeping only the first occurrence of duplicate Entrez IDs within the input. Note that this is not ideal and for a real experiment you should print out a list of duplicates, carefully review these and choose which and how to retain based on your biological context.

First, convert map the ENSEMBL gene IDs from our 'ranked' list to ENTREZ gene IDs: 

```{r convert gene IDs}
# Convert the Ensembl IDs to Entrez IDs, dropping NAs
converted_ids <- bitr(names(ranked), 
                      fromType = "ENSEMBL", 
                      toType = "ENTREZID", 
                      OrgDb = org.Hs.eg.db, 
                      drop = TRUE)
```
<1% failing to map is pretty good. 

The 1:many mappings warning means that some of our gene IDs matched more than 1 ENTREZ ID. We need to ensure that the final list we provide to GSEA does not contain duplicates. This needs to happen at two stages: first of all, ensuring that each ENSEMBL ID is mapped to only one ENTREZ ID, and then once the final converted vector has been created, check it for duplicated ENTREZ IDs, which could occur when two different ENSEMBL IDs from our input map to the the same ENTREZ ID. 

The below code does this by selecting the first of each set of duplicates. This is not ideal. In a real experiment, you should print out the duplicates and directly manage how to handle them by reviewing the gene IDs involved and deciding whether it is valid to select one ID over another, or at times you may choose to merge the values for duplicate genes.   

```{r filter converted ids }

# Handle any `1:many mapping` (ENSEMBL ID matches >1 ENTREZID) by keeping only the first Entrez ID for each Ensembl ID (not ideal, see note above)
converted_ids <- converted_ids[!duplicated(converted_ids$ENSEMBL), ]

# Keep only the rows with valid Entrez IDs
converted_ids <- converted_ids[!is.na(converted_ids$ENTREZID), ]

# Filter the ranked gene list to include only the successfully mapped Ensembl IDs
ranked_entrez <- ranked[names(ranked) %in% converted_ids$ENSEMBL]

# Replace the Ensembl IDs with the corresponding Entrez IDs in the ranked vector
names(ranked_entrez) <- converted_ids$ENTREZID[match(names(ranked_entrez), converted_ids$ENSEMBL)]

# Remove duplicates from the vector by keeping only the first occurrence of each Entrez IDs (not ideal, see note above) 
ranked_entrez <- ranked_entrez[!duplicated(names(ranked_entrez))]

# Inspect the vector
head(ranked_entrez)
tail(ranked_entrez)

```
Looks good! Now we are ready to enrich!

# 4. Run GSEA over KEGG database

Now run GSEA over the KEGG database with `gseKEGG` function, setting a `seed` value and `kegg` as our gene ID type. this may take a minute or two to run. 


```{r gseKEGG}
gsea_kegg <- gseKEGG( 
  ranked_entrez, 
  organism = "hsa", 
  keyType = "kegg", 
  exponent = 1, 
  minGSSize = 10, 
  maxGSSize = 500, 
  eps = 1e-10, 
  pvalueCutoff = 0.05, 
  pAdjustMethod = "BH",
  verbose = TRUE, 
  use_internal_data = FALSE, 
  seed = FALSE, 
  by = "fgsea"
)


```

We have 3 warnings, one about ties in the ranked list, which we could resolve manually by reviewing the raw data, or just ignore it as it is only 0.01% of the list.

The second warning may be resolved by following the suggestion to set `nPermSimple = 10000`. How frustrating that this parameter is not described within the `gseKEGG` help menu, nor the `clusterProfiler` PDF at all!  

Let's rerun following both suggestions, to use permutations (`nPermSimple`) and set `eps = 0`. We will keep the rest of the arguments the same as before.    

```{r gseKEGG perms}
gsea_kegg <- gseKEGG( 
  ranked_entrez, 
  organism = "hsa", 
  keyType = "kegg", 
  exponent = 1, 
  minGSSize = 10, 
  maxGSSize = 500, 
  eps = 0, 
  pvalueCutoff = 0.05, 
  pAdjustMethod = "BH",
  verbose = TRUE, 
  use_internal_data = FALSE, 
  seed = FALSE, 
  by = "fgsea",
  nPermSimple = 10000
)

```
Great, those last 2 warnings have resolved and we only have the expected one about tied rankings. 


# 5. Visualise GSEA KEGG results 


## Tabular results 

First, let's preview the results.  


```{r preview gsea results}
print(gsea_kegg)

```

We can see 41 significant enrichments.   

Extract results to a TSV file. This will print the significant enrichments, sorted by adjusted P value. 

```{r print GSEA results table }

write.table(gsea_kegg, file = "clusterProfiler_gseKEGG_results.tsv", sep = "\t", quote = FALSE, row.names = FALSE)

```

You can view the table in the `editor` pane by clicking on it from the `Files` pane.  


## dotplot 

A dotplot is an easy to interpret plot. The size of the dot is proportional to the number of genes (count) in that term. A higher GeneRatio indicates that a larger portion of the gene set is significantly altered or associated with the observed changes in gene expression. 

We can change the number of top terms that are plotted with the `showCategory` parameter. 

```{r GSEA KEGG dotplot }

clusterProfiler::dotplot(
  gsea_kegg,
  x = "geneRatio",
  color = "p.adjust",
  orderBy = "x",
  showCategory = 15,
  font.size = 8
  ) +
  ggtitle("GSEA KEGG")

```



## upsetplot

The upset plot shows the pattern of shared genes among the enriched terms (since a gene can belong to multiple terms or pathways).

For ORA, upsetplot will calculate the overlaps among different gene sets. 

For GSEA, it will plot the fold change distributions of different categories (e.g. unique to pathway, overlaps among different pathways).

`n` controls the number of terms plotted - here we have restricted to 10 for ease of viewing. Plot view is quite small within a notebook, but if you wanted to plot more terms, you could print to an A4 size output file for enhanced clarity. 



```{r GSEA KEGG upset plot}

# n = the number of top enrichments to plot
enrichplot::upsetplot(gsea_kegg, n = 10)

```



## emapplot

The enrichment map plot organises enriched terms into a network with edges connecting overlapping gene sets. Overlapping gene sets cluster together.

It is required to run the function `pairwise_termsim` before producing the plot. 


```{r GSEA KEGG emapplot}
# calculate pairwise similarities between the enriched terms
gsea_kegg <- enrichplot::pairwise_termsim(gsea_kegg)

# plot
enrichplot::emapplot(gsea_kegg, showCategory = 15)

```

## treeplot

The treeplot provides the same information as the emapplot but in a different visualisation. 

Each node is a term, and the number of genes associated with the term is shown by the dot size, with P values by dot colour. 

Terms that share more genes or biological functions will be closer together in the tree structure. Clades are colour coded and 'cluster tags' assigned. You can control the number of words in the tag (default is 4). The user guide describes the argument `nWords` however running that will throw an error (it says 'warning' but its fatal so to me that's an error!):

```
"Warning: Use 'cluster.params = list(label_words_n = your_value)' instead of 'nWords'.
 The nWords parameter will be removed in the next version."
```

This plot also requires the pairwise similarity matrix calculation that emapplot does. Since we have already run it, it is hashed out in the code chunk below. 

Plot view within the notebook affects the clarity of the cluster tags, however printing this plot to a file would resolve that. 

```{r treeplot GSEA KEGG, fig.width=12}
# calculate pairwise similarities between the enriched terms
#gsea_kegg <- enrichplot::pairwise_termsim(gsea_kegg)

enrichplot::treeplot(gsea_kegg, showCategory = 15, color = "p.adjust", cluster.params = list(label_words_n = 5))
```

## cnetplot

The cnetplot is helpful to understanding which genes are involved in the enriched terms, details that are not available in the plots generated so far. It depicts the linkages of genes and terms as a network. 

For GSEA, where all genes (not just DEGs) are used, only the 'core' enriched genes are used to create the network plot. These are the 'leading edge genes', those genes up to the point where the Enrichment Score (ES) gets maximised from the base zero. In other words, the subset of genes that are most strongly associated with a specific term. 

There are a few parameters to play around with here to get a readable plot. 

Try changing the number of terms plotted (`showCategory`) and the `node_label` which controls whether labels are put on terms, genes (`item`), or `all`. 

Since the information that is attempted to be plotted is complex, having a large number of terms and attempting to label everything won't look very informative! If you want to plot both gene IDs and term names, you will need to plot a small number of categories. 


```{r GSEA KEGG cnetplot}

# cex_label_gene to reduce the font size for gene ID
# node_label = one of ’all’, ’none’, ’category’ and ’item’
# showCategory = number of terms to plot

enrichplot::cnetplot(gsea_kegg, showCategory = 8, cex_label_gene = 0.5, cex_label_category = 0.8, colorEdge = TRUE, node_label = "category")




```


You can also plot the interaction between specific terms. This is helpful to obtain gene ID level resolution for term interactions of interest. 

The 3 terms listed below are for 'IL-17 signaling pathway', 'Viral protein interaction with cytokine and cytokine receptor' and 'Chemokine signaling pathway' which are top 10 enrichments with a relationship of shared genes, evident from the plot above. 

Run the code below or select a handful of terms of your choosing from the results table we printed earlier. We need the KEGG ID (column 1).  

```{r cnetplot custom terms}
# Select terms of interest 
select_terms <- c("hsa04657", "hsa04061", "hsa04062") 

# Filter the gseaResult object based on the term IDs
# must keep it as a gsea result type and not as a dataframe when filtering
gsea_kegg_select <- gsea_kegg
gsea_kegg_select@result <- gsea_kegg@result[gsea_kegg@result$ID %in% select_terms, ]

# Plot with cnetplot
enrichplot::cnetplot(gsea_kegg_select, cex_label_gene = 0.5, cex_label_category = 0.8, colorEdge = TRUE, node_label = "all")


```

Now we can clearly see the gene IDs for this network. 





## heatplot

Like the upset plot, the heatplot shows shared genes across enriched terms. When there are a lot of genes, it can be poorly readable, especially within the notebook. This function does not include a parameter to restrict to 'core' genes like the `cnetplot` or `ridgeplot` so even when plotting a very small number of enriched terms, the X-axis is too cramped to be readable.



```{r heatplot GSEA KEGG }
enrichplot::heatplot(gsea_kegg, showCategory = 3)
```
The gseKEGG result contains a data column containing the core/leading edge genes: 

```{r show GES result columns}
colnames(gsea_kegg@result)
```

So we can extract those and provide these to the heatmap to try to improve clarity. The downside of course is that we then lose some of the information about which genes are shared across terms.


```{r heatplot GSEA KEGG core genes}

# create an object that contains the core genes grouped by term and their fold change values 
ranked_core_genes <- ranked[names(ranked) %in% gsea_kegg$core_enrichment]

# Plot with just core genes
enrichplot::heatplot(gsea_kegg, foldChange = ranked_core_genes, showCategory = 3)

```

Saving to a file only improves things slightly. 

```{r}
png("clusterprofiler_gseKEGG_heatplot.png", width = 11.7, height = 8.3, units = "in", res = 300)
#enrichplot::heatplot(gsea_kegg, showCategory = 3)
enrichplot::heatplot(gsea_kegg, foldChange = ranked_core_genes, showCategory = 3)
dev.off()

```



## ridgeplot

This function is specific for GSEA. It does not apply to ORA, since it plots NES.  

The height of the ridge in the ridge plot represents the density of genes from the gene set at different points in the ranked list.

The area under the curve represents the distribution of these genes across the ranked list. 

Higher peaks and more concentrated areas under the curve at the top of the list indicate stronger enrichment.


```{r ridgeplot  gsea KEGG, fig.height=7, fig.width=7}
enrichplot::ridgeplot(gsea_kegg, 
  showCategory = 15, 
  fill = "p.adjust", 
  core_enrichment = TRUE, 
  label_format = 30, 
  orderBy = "NES", 
  decreasing = FALSE )
```

## gseaplot

Another GSEA-specific plot, which shows the contribution to the normalised enrichment score (NES) of genes across the gene list.

The gseaplot can plot one term at a time. 

The term 'hsa04020' (Calcium signaling pathway) has a positive NES, an adjusted P value of 0.00046 and a set size of 279. 


```{r gseaplot GSEA KEGG upreg, fig.width=10 }

gene_set_id <- "hsa04020"

enrichplot::gseaplot( gsea_kegg,
  gene_set_id, 
  by = "all", 
  title = paste("GSEA KEGG result:", gene_set_id),
  color = "black", 
  color.line = "green", 
  color.vline = "#FA5860"
)

```

The term 'hsa04062' (Chemokine signaling pathway) has a negative NE, a highyl significant adjusted P value of 1.11E-06 and a set size of 129. 

```{r gseaplot GSEA KEGG downreg, fig.width=10 }

gene_set_id <- "hsa04062"

enrichplot::gseaplot( gsea_kegg,
  gene_set_id, 
  by = "all", 
  title = paste("GSEA KEGG result:", gene_set_id),
  color = "black", 
  color.line = "green", 
  color.vline = "#FA5860"
)


```


The term 'hsa05163' has a slightly negative NES and a borderline adjusted P value of 0.046.

```{r gseaplot GSEA KEGG nonsignif, fig.width=10 }

gene_set_id <- "hsa05163"

enrichplot::gseaplot( gsea_kegg,
  gene_set_id, 
  by = "all", 
  title = paste("GSEA KEGG result:", gene_set_id),
  color = "black", 
  color.line = "green", 
  color.vline = "#FA5860"
)


```

## volcano plot

The `volplot` function within `enrichplot` does not support GSEA result, but we can use `ggplot2` for this. 

The volcano plot has the advantage of showing whether the genes in the enriched terms were predominantly from the top (upregulated) or bottom (downregulated) end of the list. 


```{r}
ggplot2::ggplot(gsea_kegg@result, aes(x = enrichmentScore, y = -log10(p.adjust), color = p.adjust)) +
  geom_point(alpha = 0.7, size = 2) +  # Adjust point size
  scale_color_gradient(low = "blue", high = "red") +  # Color by p.adjust values
  theme_minimal() +
  labs(title = "GSEA KEGG",
       x = "Enrichment Score (NES)",
       y = "-log10(Adjusted P-value)",
       color = "Adjusted P-value") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +  # Rotate x-axis labels for readability
  geom_vline(xintercept = 0, linetype = "dashed", color = "black") +  # Add vertical line at x=0
  geom_hline(yintercept = -log10(0.05), linetype = "dashed", color = "black") +  # Add horizontal line at p=0.05 cutoff
  geom_text(aes(label = Description),
            hjust = 0.5,
            vjust = -0.5,  # Move labels higher off the points
            size = 3,
            check_overlap = TRUE,
            alpha = 0.7)  # Add labels for each pathway term

```


# 6. Save versions and session details 

R version and package versions:

```{r info }
sessionInfo()
```

And RStudio version. Typically, we would simply run `RStudio.Version()` to print the version details. However, when we knit this document to HTML, the `RStudio.Version()` function is not available and will cause an error. So to make sure our version details are saved to our static record of the work, we will save to a file, then print the file contents back into the notebook. 


```{r rstudio version - not run during knit, eval=FALSE}
# Get RStudio version information
rstudio_info <- RStudio.Version()

# Convert the version information to a string
rstudio_version_str <- paste(
  "RStudio Version Information:\n",
  "Version: ", rstudio_info$version, "\n",
  "Release Name: ", rstudio_info$release_name, "\n",
  "Long Version: ", rstudio_info$long_version, "\n",
  "Mode: ", rstudio_info$mode, "\n",
  "Citation: ", rstudio_info$citation,
  sep = ""
)

# Write the output to a text file
writeLines(rstudio_version_str, "rstudio_version.txt")

```

```{r rstudio version saved from text}

# Read the saved version information from the file
rstudio_version_text <- readLines("rstudio_version.txt")

# Print the version information to the document
rstudio_version_text

```


# 7.  Knit workbook to HTML

The last task is to knit the notebook. Our notebook is editable, and can be changed. Deleting code deletes the output, so we could lose valuable details. If we knit the notebook to HTML, we have a permanent static copy of the work.

On the editor pane toolbar, under Preview, select Knit to HTML.

If you have already run Preview, you will see Knit instead of Preview.

The HTML file will be saved in the same directory as the notebook, and with the same filename, but the .Rmd prefix will be replaced by .html. The knit HTML will typically open automatically once complete. If you receive a popup blocker error, click cancel, and in the Files pane of RStudio, single click the gprofiler.html file and select View in Web Browser.

Note that the notebook will only successfully knit if there are no errors in the code. You can 'preview' HTML with code errors.







